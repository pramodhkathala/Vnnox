<script>
    // --- Constants ---
    const MM_PER_METER = 1000;
    const MM_PER_INCH = 25.4;
    const MM_PER_FOOT = MM_PER_INCH * 12;
    const METER_TO_FEET = 3.28084;
    const PIXELS_PER_PORT_DEFAULT = 650000; // fallback
    // Buffers: set global buffer to 5% as requested
    const GLOBAL_PORT_BUFFER_PCT = 0.05; // 5%
    const POWER_BUFFER = 1.15;
    const WEIGHT_BUFFER = 1.15;
    const MARGIN_PERCENT_TEXT = "15%";
    // --- PeopleLink LED Models ---
    const LED_PRODUCTS = {
        'cob_09': { name: "PeopleLink COB (0.9375mm)", pitch_mm: 0.9375, cabW_mm: 600, cabH_mm: 337.5, cabPixW: 640, cabPixH: 360, modulesPerCab: 8, weight_kg: 4.6, nits_range: "600-1000", maxPower_W_m2: 300 },
        'cob_125': { name: "PeopleLink COB (1.25mm)", pitch_mm: 1.25, cabW_mm: 600, cabH_mm: 337.5, cabPixW: 480, cabPixH: 270, modulesPerCab: 8, weight_kg: 4.6, nits_range: "600-800", maxPower_W_m2: 300 },
        'cob_15': { name: "PeopleLink COB (1.5625mm)", pitch_mm: 1.5625, cabW_mm: 600, cabH_mm: 337.5, cabPixW: 384, cabPixH: 216, modulesPerCab: 8, weight_kg: 4.6, nits_range: "600-800", maxPower_W_m2: 300 },
        'indoor_186': { name: "PeopleLink SMD Indoor (1.86mm)", pitch_mm: 1.86, cabW_mm: 640, cabH_mm: 480, cabPixW: 344, cabPixH: 258, modulesPerCab: 6, weight_kg: 6.24, nits_range: "450-600", maxPower_W_m2: 560 },
        'indoor_20': { name: "PeopleLink SMD Indoor (2.0mm)", pitch_mm: 2.0, cabW_mm: 640, cabH_mm: 480, cabPixW: 320, cabPixH: 240, modulesPerCab: 6, weight_kg: 6.24, nits_range: "450-600", maxPower_W_m2: 560 },
        'indoor_25': { name: "PeopleLink SMD Indoor (2.5mm)", pitch_mm: 2.5, cabW_mm: 640, cabH_mm: 480, cabPixW: 256, cabPixH: 192, modulesPerCab: 6, weight_kg: 6.24, nits_range: "450-600", maxPower_W_m2: 560 },
        'outdoor_40': { name: "PeopleLink SMD Outdoor (4.0mm)", pitch_mm: 4.0, cabW_mm: 960, cabH_mm: 960, cabPixW: 240, cabPixH: 240, modulesPerCab: 18, weight_kg: 8.28, nits_range: "4500-5000", maxPower_W_m2: 937.5 },
        'outdoor_667': { name: "PeopleLink SMD Outdoor (6.67mm)", pitch_mm: 6.67, cabW_mm: 960, cabH_mm: 960, cabPixW: 144, cabPixH: 144, modulesPerCab: 18, weight_kg: 8.28, nits_range: "4500-5000", maxPower_W_m2: 937.5 },
        'outdoor_80': { name: "PeopleLink SMD Outdoor (8.0mm)", pitch_mm: 8.0, cabW_mm: 960, cabH_mm: 960, cabPixW: 120, cabPixH: 120, modulesPerCab: 18, weight_kg: 8.28, nits_range: "4500-5000", maxPower_W_m2: 937.5 },
        'outdoor_100': { name: "PeopleLink SMD Outdoor (10.0mm)", pitch_mm: 10.0, cabW_mm: 960, cabH_mm: 960, cabPixW: 96, cabPixH: 96, modulesPerCab: 18, weight_kg: 8.28, nits_range: "4500-5000", maxPower_W_m2: 937.5 },
    };

    const H_SERIES_DEFAULTS = {
        SPLICER_NAME: 'H5 Modular Splicer (5U) - Suggested for H-Series Cards',
        CONTROLLER_OPTIONS: [
            { model: 'VX1000', display: 'VX1000 Processor (AIO) - Max 6.5M Pixels', pixels: 6500000, type: 'AIO' },
            { model: 'VX600', display: 'VX600 Processor (AIO) - Max 3.9M Pixels', pixels: 3900000, type: 'AIO' },
            { model: 'VX400', display: 'VX400 Processor (AIO) - Max 2.6M Pixels', pixels: 2600000, type: 'AIO' },
            { model: 'H9', display: 'H9 Processor (Modular Frame)', pixels: 65000000, type: 'Modular' },
            { model: 'H5', display: 'H5 Processor (Modular Frame)', pixels: 32500000, type: 'Modular' },
        ],
        INPUT_CARD_OPTIONS: [
            { model: "H_1xHDMI2.0 input card (4K)", display: "1x 4K HDMI (Single Input)", qty: 1, type: "4K Single Input" },
            { model: "H_2xHDMI2.0 input card (4K)", display: "2x 4K HDMI (Dual Input)", qty: 1, type: "4K Dual Input" },
            { model: "H_4xHDMI input card (1080P)", display: "4x FHD HDMI (Quad Input)", qty: 1, type: "HD Quad Input" },
        ],
        DEFAULT_INPUT_CARD_MODEL: "H_1xHDMI2.0 input card (4K)",
        DEFAULT_INPUT_CARD_QTY: 2,
        OUTPUT_CARD_20_PORTS: 20,
        OUTPUT_CARD_20_MODEL: "H_20xRJ45 Sending Card",
        OUTPUT_CARD_16_PORTS: 16,
        OUTPUT_CARD_16_MODEL: "H_16xRJ45 Sending Card",
    };

    // Cabinets-per-long-LAN mapping — buffer fields replaced by global 5% buffer
    const CABINETS_PER_LONG_LAN = {
        'cob_09': { cabinetsPerRun: 2 }, // COB 0.9375 mm → 2 cabinets / long LAN cable
        'cob_125': { cabinetsPerRun: 5 }, // COB 1.25 mm → 5 cabinets / long LAN cable
        'cob_15': { cabinetsPerRun: 7 }, // COB 1.5625 mm → 7 cabinets / long LAN cable
        // SMD handled separately (pixel->port + 5% buffer)
    };

    // --- Parts Catalog (from provided spreadsheet image) ---
    const PARTS_CATALOG = {
        // Controllers / Processors
        'VX1000': { part: 'TP-AIO-VX1000', desc: 'AIO LED Video Processor/Controller' },
        'VX600': { part: 'TP-AIO-VX600', desc: 'AIO LED Video Processor/Controller' },
        'VX400': { part: 'TP-AIO-VX400', desc: 'AIO LED Video Processor/Controller' },
        'H9': { part: 'TP-PRO-H9', desc: 'Modular 9-Slot Processor Frame' },
        'H5': { part: 'TP-PRO-H5', desc: 'Modular 5-Slot Processor Frame' },
        // Sending / Input / Output Cards
        'H_20xRJ45 Sending Card': { part: 'TP-XOC-RJ45-20', desc: 'H_20 x RJ45 Sending Card' },
        'H_16xRJ45 Sending Card': { part: 'TP-XOC-RJ45-16', desc: 'H_16 x RJ45 Sending Card' },
        'H_1xHDMI2.0 input card (4K)': { part: 'TP-XIC-HDMI2.0', desc: 'H_1x HDMI2.0 Input Card (4K)' },
        'H_2xHDMI2.0 input card (4K)': { part: 'TP-XIC-HDMI2.0-2', desc: 'H_2x HDMI2.0 Input Card (4K)' },
        'H_4xHDMI input card (1080P)': { part: 'TP-XIC-HDMI-4', desc: 'H_4x HDMI Input Card (1080P)' },
        'H_4_HDMI_Out': { part: 'TP-XOC-HDMI4', desc: 'H_4 x HDMI Output Card' },
        // Power / accessories
        'H_800W_PSU': { part: 'TP-XPS-H800W', desc: 'H_800W Power Supply' },
        'H_preview_card': { part: 'TP-XOC-RJ45-2-HDMI1', desc: 'H_2 x RJ45 + 1 x HDMI preview card' },
        'VNNOX_Cloud': { part: 'TBD', desc: 'One-Stop Cloud Platform VNNOX Standard' },
        'H_audio_card': { part: 'TBD', desc: 'H_2xAudio input+2xAudio output card' },
        // Active LED Products / Modules (COB)
        'PPL-COB-09': { part: 'PPL-COB-MDL-CU-09', desc: 'PeopleLink Active LED | 0.9PP COB (Including Modules)' },
        'PPL-COB-125': { part: 'PPL-COB-MDL-CU-12', desc: 'PeopleLink Active LED | 1.25PP COB (Including Modules)' },
        'PPL-COB-156': { part: 'PPL-COB-MDL-CU-12', desc: 'PeopleLink Active LED | 1.56PP COB (Including Modules)' },
        // SMB Indoor
        'PPL-SMD-18': { part: 'PPL-SMD-MDL-CU-18', desc: 'PeopleLink ActiveLED | 1.8PP Video LED Cabinets (Including Modules)' },
        'PPL-ALD-CU': { part: 'PPL-ALD-CU', desc: 'PeopleLink ActiveLED | Video Wall Cabinet Unit (640x480mm)' },
        'PDS-TP-15-T': { part: 'PDS-TP-15-T', desc: 'PeopleLink ActiveLED | 2.0PP Video LED Modules' },
        // SMB Outdoor
        'PPL-SMD-40': { part: 'PPL-SMD-MDL-CU-40', desc: 'PeopleLink ActiveLED | 4.0PP Outdoor Video Wall Cabinet' },
        'PPL-SMD-667': { part: 'PPL-SMD-MDL-CU-667', desc: 'PeopleLink ActiveLED | 6.67PP Outdoor Video Wall Cabinet' },
        'PPL-SMD-80': { part: 'PPL-SMD-MDL-CU-80', desc: 'PeopleLink ActiveLED | 8.0PP Outdoor Video Wall Cabinet' },
        'PPL-SMD-100': { part: 'PPL-SMD-MDL-CU-100', desc: 'PeopleLink ActiveLED | 10.0PP Outdoor Video Wall Cabinet' },
        // Mounting
        'PPL-FMOUNT-60': { part: 'PPL-FMOUNT-60', desc: 'Front Maintenance Mounting Frame (600x337.5mm)' },
        'PPL-FMOUNT-64': { part: 'PPL-FMOUNT-64', desc: 'Front Maintenance Mounting Frame (640x480mm)' },
        'PPL-FMOUNT-96': { part: 'PPL-FMOUNT-96', desc: 'Front Maintenance Mounting Frame (960x960mm)' },
        'PPL-FMOUNT-ADAPTOR': { part: 'PPL-FMOUNT-ADAPTOR', desc: 'Cabinet to Wall Adaptor (Per Cabinet)' },
    };

    // --- State Variables ---
    let finalCalculationData = null;
    let contactInfo = { email: '', phone: '' };

    // --- Helper Functions ---
    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
    function formatNumber(num, fixed = 0) { return num.toFixed(fixed).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
    function escapeHtml(unsafe) {
        return unsafe.replace(/[&<>"'`=\/]/g, function (s) {
            return ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
                '/': '&#x2F;',
                '`': '&#x60;',
                '=': '&#x3D;'
            })[s];
        });
    }

    // Helper: build BOQ items using calculated data + parts catalog
    function generateBOQList(data) {
        // returns array of { combined, partcode, qty, unit }
        const list = [];
        // Controller
        let ctrlKey = null;
        if (data.controllerName) {
            const m = data.controllerName.match(/(TB40|TB60|VX400|VX600|VX1000|4K Prime|4K Prime Pro|H2|H5|H9|H15|H15E|H20)/i);
            if (m) ctrlKey = m[0];
            else {
                if (data.controllerName.includes('TB40')) ctrlKey = 'TB40';
                if (data.controllerName.includes('TB60')) ctrlKey = 'TB60';
                if (data.controllerName.includes('H5')) ctrlKey = 'H5';
                if (data.controllerName.includes('H2')) ctrlKey = 'H2';
            }
        }
        const ctrlPart = (ctrlKey && PARTS_CATALOG[ctrlKey])
            ? PARTS_CATALOG[ctrlKey].part : (PARTS_CATALOG[data.controllerName] ? PARTS_CATALOG[data.controllerName].part : 'TBD');
        const ctrlDesc = (ctrlKey && PARTS_CATALOG[ctrlKey]) ? PARTS_CATALOG[ctrlKey].desc : (data.controllerName || 'Controller/Processor');
        list.push({ combined: `Controller/Processor — ${ctrlDesc}`, partcode: ctrlPart || 'TBD', qty: 1, unit: 'PCS' });

        // Receiving Cards (embedded)
        list.push({ combined: `Receiving Cards (embedded) — ${data.totalRecCards} R-cards`, partcode: 'Embedded', qty: data.totalRecCards, unit: 'PCS' });

        // Sending / Output cards (modular)
        if (data.controllerType && data.controllerType.includes('Modular')) {
            const outCardModel = data.outputCardModel || H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL;
            const outCardPart = PARTS_CATALOG[outCardModel] ? PARTS_CATALOG[outCardModel].part : 'TBD';
            list.push({ combined: `Modular Output Card — ${outCardModel}`, partcode: outCardPart, qty: data.requiredSendCards, unit: 'PCS' });

            // Input Card
            const inputCardModel = data.inputCardModel.split('|')[0] || H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_MODEL;
            const inputCardPart = PARTS_CATALOG[inputCardModel] ? PARTS_CATALOG[inputCardModel].part : 'TBD';
            list.push({ combined: `Input Card — ${inputCardModel}`, partcode: inputCardPart, qty: data.inputCardQty, unit: 'PCS' });

            // Splicer
            if (data.splicerSolution) {
                list.push({ combined: `Splicer Frame/Solution — ${data.splicerSolution}`, partcode: 'TBD', qty: 1, unit: 'PCS' });
            }

            // Optional HDMI Output Card
            if (data.includeHdmiOutput) {
                list.push({ combined: `Optional Output Card — H_4 x HDMI Output Card (optional)`, partcode: PARTS_CATALOG['H_4_HDMI_Out'] ? PARTS_CATALOG['H_4_HDMI_Out'].part : 'TBD', qty: 1, unit: 'PCS' });
            }
        }

        // Long ethernet ports / controller ports
        list.push({ combined: `Controller → Wall Long Ethernet Ports (post-buffer)`, partcode: 'TBD', qty: data.requiredPortsBuffered, unit: 'PCS' });
        list.push({ combined: `Inter-Cabinet Short Ethernet (CAT6)`, partcode: 'TBD', qty: data.requiredShortEthernet, unit: 'PCS' });

        // LED Cabinets & Modules
        const ledPartKey = (() => {
            if (data.pixelPitch_mm <= 1.0) return 'PPL-COB-09';
            if (data.pixelPitch_mm <= 1.3) return 'PPL-COB-125';
            if (data.pixelPitch_mm <= 1.7) return 'PPL-COB-156';
            if (data.cabinetW_mm === 640 && data.pixelPitch_mm <= 2.0) return 'PPL-SMD-18';
            if (data.cabinetW_mm === 640) return 'PPL-ALD-CU'; // Generic SMD indoor cabinet (2.5mm)
            if (data.cabinetW_mm === 960 && data.pixelPitch_mm <= 4.0) return 'PPL-SMD-40';
            if (data.cabinetW_mm === 960 && data.pixelPitch_mm <= 6.67) return 'PPL-SMD-667';
            if (data.cabinetW_mm === 960 && data.pixelPitch_mm <= 8.0) return 'PPL-SMD-80';
            if (data.cabinetW_mm === 960) return 'PPL-SMD-100';
            return 'PPL-ALD-CU';
        })();
        const ledPart = PARTS_CATALOG[ledPartKey] ? PARTS_CATALOG[ledPartKey].part : 'TBD';
        list.push({ combined: `LED Cabinets (including modules) — ${data.productName}`, partcode: ledPart || 'TBD', qty: data.totalCabinets, unit: 'PCS' });

        // Spare modules
        const sparePct = (data.productName && data.productName.toLowerCase().includes('cob')) ? 0.05 : 0.10;
        const spareModulesQty = Math.max(1, Math.round(data.totalModules * sparePct));
        list.push({ combined: `Spare Modules (Recommended ${Math.round(sparePct * 100)}% of total)`, partcode: 'TBD', qty: spareModulesQty, unit: 'PCS' });

        // Mounting Frames
        let mountPartKey = null;
        if (data.cabinetW_mm === 600) mountPartKey = 'PPL-FMOUNT-60';
        else if (data.cabinetW_mm === 640) mountPartKey = 'PPL-FMOUNT-64';
        else if (data.cabinetW_mm === 960) mountPartKey = 'PPL-FMOUNT-96';
        if (mountPartKey) {
            list.push({ combined: `Front Maintenance Mounting Frame (Per Cabinet)`, partcode: PARTS_CATALOG[mountPartKey].part, qty: data.totalCabinets, unit: 'PCS' });
        } else {
            list.push({ combined: `Cabinet to Wall Adaptor`, partcode: PARTS_CATALOG['PPL-FMOUNT-ADAPTOR'].part, qty: data.totalCabinets, unit: 'PCS' });
        }

        // Power Supplies
        const psuQty = Math.max(1, Math.ceil(data.maxPower_W_buffered / 800)); // Assuming 800W PSUs
        list.push({ combined: `Modular Power Supplies (800W/ea) - Buffered`, partcode: PARTS_CATALOG['H_800W_PSU'].part, qty: psuQty, unit: 'PCS' });

        return list;
    }

    // --- Core Logic Functions ---
    function toggleMeasurementFields() {
        const unit = document.getElementById('unit').value;
        const isDiagonal = (unit === 'inches');
        document.getElementById('widthLabel').textContent = `Desired Width (${unit === 'feet' ? 'ft' : 'm'})`;
        document.getElementById('heightLabel').textContent = `Desired Height (${unit === 'feet' ? 'ft' : 'm'})`;
        document.getElementById('aspectRatioLabel').textContent = 'Target Aspect Ratio (Optional)';
        document.getElementById('widthGroup').classList.toggle('hidden', isDiagonal);
        document.getElementById('heightGroup').classList.toggle('hidden', isDiagonal);
        document.getElementById('diagonalGroup').classList.toggle('hidden', !isDiagonal);
        if (isDiagonal) {
            document.getElementById('width').value = '';
            document.getElementById('height').value = '';
        } else {
            document.getElementById('diagonal').value = '';
        }
        document.getElementById('errorMessage').classList.add('hidden');
    }

    function calculateLEDWall() {
        const productKey = document.getElementById('productModel').value;
        const unit = document.getElementById('unit').value;
        const widthInput = document.getElementById('width').value;
        const heightInput = document.getElementById('height').value;
        const diagonalInput = document.getElementById('diagonal').value;
        const aspectRatioKey = document.getElementById('aspectRatio').value;
        let inputW = parseFloat(widthInput);
        let inputH = parseFloat(heightInput);
        let inputD = parseFloat(diagonalInput);
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.classList.add('hidden');

        if (!productKey || !unit || ((unit !== 'inches' && (!inputW && !inputH)) || (unit === 'inches' && !inputD))) {
            errorDiv.textContent = 'ERROR: Please select a Model, Unit, and enter valid dimensions to continue.';
            errorDiv.classList.remove('hidden');
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return null;
        }

        const isDiagonal = (unit === 'inches');
        const details = LED_PRODUCTS[productKey];
        const cabinetW_mm = details.cabW_mm;
        const cabinetH_mm = details.cabH_mm;
        let desiredW_mm, desiredH_mm;
        let usedW_input, usedH_input, usedRatio = aspectRatioKey || 'None Specified';
        let inputDiagonal;

        if (unit === 'inches') {
            const ratioToUse = aspectRatioKey || '16:9';
            const [ratioW, ratioH] = ratioToUse.split(':').map(Number);
            const ratioDiagonal = Math.sqrt(ratioW * ratioW + ratioH * ratioH);
            const factor = inputD / ratioDiagonal;
            desiredW_mm = factor * ratioW * MM_PER_INCH;
            desiredH_mm = factor * ratioH * MM_PER_INCH;
            usedW_input = `${(desiredW_mm / MM_PER_METER).toFixed(2)}m`;
            usedH_input = `${(desiredH_mm / MM_PER_METER).toFixed(2)}m`;
            inputDiagonal = inputD;
        } else {
            const conversionFactor = (unit === 'feet') ? MM_PER_FOOT : MM_PER_METER;
            let hasW = !isNaN(inputW) && inputW > 0;
            let hasH = !isNaN(inputH) && inputH > 0;

            if (hasW) desiredW_mm = inputW * conversionFactor;
            if (hasH) desiredH_mm = inputH * conversionFactor;

            if (hasW && hasH) {
                // Both provided, use both
                usedW_input = `${inputW}${unit === 'feet' ? 'ft' : 'm'}`;
                usedH_input = `${inputH}${unit === 'feet' ? 'ft' : 'm'}`;
            } else if (hasW) {
                // Width provided, calculate H based on target ratio or cabinet AR
                const [ratioW, ratioH] = (aspectRatioKey || `${cabinetW_mm}:${cabinetH_mm}`).split(':').map(Number);
                desiredH_mm = desiredW_mm * (ratioH / ratioW);
                usedW_input = `${inputW}${unit === 'feet' ? 'ft' : 'm'}`;
                usedH_input = 'Calculated from W';
                if (!aspectRatioKey) usedRatio = `Inferred from Cabinet AR (${cabinetW_mm}:${cabinetH_mm})`;
            } else if (hasH) {
                // Height provided, calculate W based on target ratio or cabinet AR
                const [ratioW, ratioH] = (aspectRatioKey || `${cabinetW_mm}:${cabinetH_mm}`).split(':').map(Number);
                desiredW_mm = desiredH_mm * (ratioW / ratioH);
                usedW_input = 'Calculated from H';
                usedH_input = `${inputH}${unit === 'feet' ? 'ft' : 'm'}`;
                if (!aspectRatioKey) usedRatio = `Inferred from Cabinet AR (${cabinetW_mm}:${cabinetH_mm})`;
            }
            inputDiagonal = 0;
        }

        // Cabinet counts and basic geometry
        let numCabW = Math.max(1, Math.round(desiredW_mm / cabinetW_mm));
        let numCabH = Math.max(1, Math.round(desiredH_mm / cabinetH_mm));
        const totalCabinets = numCabW * numCabH;
        const totalModules = totalCabinets * details.modulesPerCab;
        const finalW_mm = numCabW * cabinetW_mm;
        const finalH_mm = numCabH * cabinetH_mm;

        const finalArea_m2 = (finalW_mm / MM_PER_METER) * (finalH_mm / MM_PER_METER);
        const finalResW = numCabW * details.cabPixW;
        const finalResH = numCabH * details.cabPixH;
        const totalPixels = finalResW * finalResH;
        const ratioGCD = gcd(finalResW, finalResH);
        const aspectRatioText = `${finalResW / ratioGCD}:${finalResH / ratioGCD}`;
        const finalDiagonal_mm = Math.sqrt(finalW_mm * finalW_mm + finalH_mm * finalH_mm);
        const finalDiagonal_in = finalDiagonal_mm / MM_PER_INCH;
        const minViewingDistance_ft = details.pitch_mm * METER_TO_FEET;

        // Power & weight
        const actualPower_W_unbuffered = finalArea_m2 * details.maxPower_W_m2;
        const maxPower_W_buffered = actualPower_W_unbuffered * POWER_BUFFER;
        const actualCurrent_A = actualPower_W_unbuffered / 220;
        const maxCurrent_A_buffered = maxPower_W_buffered / 220;
        const actualCabinetWeight_unbuffered = details.weight_kg * totalCabinets;
        const totalWallWeight_buffered = actualCabinetWeight_unbuffered * WEIGHT_BUFFER;

        // --- LAN / Port Rules with global 5% buffer ---
        const ports_by_pixels = Math.max(1, Math.ceil(totalPixels / PIXELS_PER_PORT_DEFAULT));
        let cabinetsRule = CABINETS_PER_LONG_LAN[productKey];
        let requiredLongEthRuns = 0;
        let ports_by_cabinets = 0;

        if (cabinetsRule) {
            // Rule 1: Use specific cabinet-per-run rule for COB
            requiredLongEthRuns = Math.max(1, Math.ceil(numCabH * numCabW / cabinetsRule.cabinetsPerRun));
            ports_by_cabinets = requiredLongEthRuns;
        } else {
            // Rule 2: Use pixel-based rule for SMD
            requiredLongEthRuns = Math.max(1, ports_by_pixels);
            ports_by_cabinets = requiredLongEthRuns;
        }

        // Final required ports is the maximum of the two rules
        const requiredPorts = Math.max(ports_by_pixels, ports_by_cabinets);
        const requiredPortsBuffered = Math.max(1, Math.ceil(requiredPorts * (1 + GLOBAL_PORT_BUFFER_PCT)));

        // Recommended Controller logic
        const suggestedController = H_SERIES_DEFAULTS.CONTROLLER_OPTIONS.find(c => c.pixels >= totalPixels) || H_SERIES_DEFAULTS.CONTROLLER_OPTIONS[H_SERIES_DEFAULTS.CONTROLLER_OPTIONS.length - 1];
        let controllerName = suggestedController.display;
        let outputCardModel = H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL;
        let outputCardPorts = H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS;
        let splicerSolution = H_SERIES_DEFAULTS.SPLICER_NAME;
        let requiredSendCards = 1;
        let inputCardModel = H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_MODEL;
        let inputCardQty = H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_QTY;
        let totalRecCards = totalCabinets;

        if (suggestedController.type === 'Modular') {
            // Calculate required output cards based on buffered ports
            requiredSendCards = Math.max(1, Math.ceil(requiredPortsBuffered / outputCardPorts));
        }

        // Short Ethernet required: (numCabW-1) * numCabH + (numCabH-1) * numCabW + totalCabinets (for runs into the cab)
        const totalCabinetConnections = (numCabW * numCabH) - 1; // minimum connections
        const requiredShortEthernet = Math.max(totalCabinetConnections, totalCabinets * 2); // Buffer to total cabinets * 2

        const finalCalculationData = {
            productName: details.name,
            pixelPitch_mm: details.pitch_mm,
            cabinetW_mm: cabinetW_mm,
            cabinetH_mm: cabinetH_mm,
            cabPixW: details.cabPixW,
            cabPixH: details.cabPixH,
            modulesPerCab: details.modulesPerCab,
            numCabW: numCabW,
            numCabH: numCabH,
            totalCabinets: totalCabinets,
            totalModules: totalModules,
            finalW_mm: finalW_mm,
            finalH_mm: finalH_mm,
            finalArea_m2: finalArea_m2,
            finalResW: finalResW,
            finalResH: finalResH,
            totalPixels: totalPixels,
            aspectRatioText: aspectRatioText,
            finalDiagonal_in: finalDiagonal_in,
            minViewingDistance_ft: minViewingDistance_ft,
            pixelDensity: totalPixels / finalArea_m2, // Added for request #6
            actualPower_W_unbuffered: actualPower_W_unbuffered,
            maxPower_W_buffered: maxPower_W_buffered,
            actualCurrent_A: actualCurrent_A,
            maxCurrent_A_buffered: maxCurrent_A_buffered,
            actualWallWeight_unbuffered: actualCabinetWeight_unbuffered,
            totalWallWeight_buffered: totalWallWeight_buffered,
            controllerName: controllerName,
            controllerType: suggestedController.type,
            requiredPorts: requiredPorts,
            requiredPortsBuffered: requiredPortsBuffered,
            requiredLongEthRuns: requiredLongEthRuns,
            requiredShortEthernet: requiredShortEthernet,
            outputCardPorts: outputCardPorts,
            outputCardModel: outputCardModel,
            requiredSendCards: requiredSendCards,
            inputCardModel: inputCardModel,
            inputCardQty: inputCardQty,
            splicerSolution: splicerSolution,
            totalRecCards: totalRecCards
        };
        return finalCalculationData;
    }

    function calculateDimensions(data) {
        const finalW_M = data.finalW_mm / MM_PER_METER;
        const finalH_M = data.finalH_mm / MM_PER_METER;
        const finalW_FT = data.finalW_mm / MM_PER_FOOT;
        const finalH_FT = data.finalH_mm / MM_PER_FOOT;
        return { finalW_M, finalH_M, finalW_FT, finalH_FT };
    }

    function showVisualization() {
        const data = finalCalculationData = calculateLEDWall();
        if (!data) return;
        const { finalW_M, finalH_M, finalW_FT, finalH_FT } = calculateDimensions(data);
        document.getElementById('enteredSummaryText').textContent = `Cabinet Matrix: ${data.numCabW}x${data.numCabH} (${data.totalCabinets} Cabinets)`;
        document.getElementById('aspectRatioValue').textContent = data.aspectRatioText;
        document.getElementById('formContainer').classList.add('minimized');
        document.getElementById('submitButton').classList.add('hidden');
        document.querySelector('.back-btn-placeholder').classList.remove('hidden');
        document.getElementById('visualization').classList.add('visible');
        document.getElementById('pixelPitchDisplay').innerHTML = `<strong>Pixel Pitch :</strong><small>${data.pixelPitch_mm} mm</small>`;
        document.getElementById('finalDimensions').innerHTML = `<strong>Actual Final Dimensions (WxH) :</strong><small>(${finalW_FT.toFixed(2)}ft x ${finalH_FT.toFixed(2)}ft) - ${finalW_M.toFixed(2)}m x ${finalH_M.toFixed(2)}m</small>`;
        document.getElementById('resolution').innerHTML = `<strong>Actual Final Resolution (WxH) :</strong><small>${data.finalResW} x ${data.finalResH}</small>`;
        document.getElementById('numCabinets').innerHTML = `<strong>Total Cabinets (W x H) :</strong><small>${data.totalCabinets} (${data.numCabW} x ${data.numCabH})</small>`;
        document.getElementById('totalModules').innerHTML = `<strong>Total Modules Required :</strong><small>${data.totalModules} (${data.modulesPerCab} per cabinet)</small>`;
        document.getElementById('finalDiagonal').innerHTML = `<strong>Final Diagonal Size :</strong><small>${data.finalDiagonal_in.toFixed(1)} in</small>`;
        document.getElementById('finalArea').innerHTML = `<strong>Final Wall Area :</strong><small>${data.finalArea_m2.toFixed(2)} m²</small>`;
        document.getElementById('totalPixels').innerHTML = `<strong>Total Pixels :</strong><small>${formatNumber(data.totalPixels, 0)}</small>`;
        document.getElementById('cabinetSize').innerHTML = `<strong>Cabinet Size :</strong><small>${data.cabinetW_mm}mm x ${data.cabinetH_mm}mm</small>`;
        document.getElementById('cabinetPixels').innerHTML = `<strong>Cabinet Resolution :</strong><small>${data.cabPixW} x ${data.cabPixH}</small>`;

        const controlSystemDetailsDiv = document.getElementById('controlSystemDetails');
        let htmlContent = `
            <span><strong>Suggested Controller/Processor :</strong><small>${data.controllerName}</small></span>
            <span><strong>Required Sending Ports (Buffered):</strong><small>${data.requiredPortsBuffered} Ports (+${(GLOBAL_PORT_BUFFER_PCT * 100).toFixed(0)}% safety buffer)</small></span>
        `;
        if (data.controllerType === 'Modular') {
            htmlContent += `
                <span><strong>Required Output Cards :</strong><small>${data.requiredSendCards} x ${data.outputCardModel} (${data.outputCardPorts} ports/card)</small></span>
                <span><strong>Input Cards (Example) :</strong><small>${data.inputCardQty} x ${data.inputCardModel.split('|')[0]}</small></span>
                <span><strong>Splicer/Processor Frame :</strong><small>${data.splicerSolution}</small></span>
            `;
        }

        htmlContent += `
            <span><strong>Min. Viewing Distance :</strong><small>${data.minViewingDistance_ft.toFixed(1)} ft</small></span>
            <span style="grid-column: 1 / -1; font-weight: 700; color: #0D47A1; border-bottom: 1px solid #0D47A1; padding-bottom: 5px; margin-bottom: 5px; margin-top: 10px;">Power and Weight (Actual Figures Only)</span>
            <span id="wallPowerActual"><strong>Max Power Consumption (Actual) :</strong><small>${formatNumber(data.actualPower_W_unbuffered, 0)} W</small></span>
            <span id="wallCurrent"><strong>Max Current Draw (Actual @220V) :</strong><small>${data.actualCurrent_A.toFixed(2)} A</small></span>
            <span id="cabinetWeightActual"><strong>Total Wall Weight (Actual Cabinets) :</strong><small>${formatNumber(data.actualWallWeight_unbuffered, 1)} kg</small></span>
        `;
        controlSystemDetailsDiv.innerHTML = htmlContent;

        const aspectRatio = data.finalW_mm / data.finalH_mm;
        const visualizationHeight = 300;
        const visGrid = document.getElementById('visGrid');
        visGrid.style.width = '100%';
        setTimeout(() => {
            try {
                const w = visGrid.clientWidth || Math.min(window.innerWidth - 200, 800);
                const computedH = Math.max(120, Math.min(visualizationHeight, Math.round(w / aspectRatio)));
                visGrid.style.height = `${computedH}px`;
            } catch (e) {
                visGrid.style.height = `${visualizationHeight}px`;
            }
        }, 50);

        document.getElementById('visWidthLabel').textContent = `${finalW_M.toFixed(2)} m (W)`;
        document.getElementById('visHeightLabel').textContent = `${finalH_M.toFixed(2)} m (H)`;

        // Cabinet overlay
        const cabinetOverlay = document.getElementById('cabinetOverlay');
        cabinetOverlay.innerHTML = '';
        cabinetOverlay.style.gridTemplateColumns = `repeat(${data.numCabW}, 1fr)`;
        cabinetOverlay.style.gridTemplateRows = `repeat(${data.numCabH}, 1fr)`;
        cabinetOverlay.style.display = 'grid';
        let tooltip = document.getElementById('cabTooltip');
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.id = 'cabTooltip';
            tooltip.className = 'tooltip-cab';
            document.body.appendChild(tooltip);
        }

        for (let r = 0; r < data.numCabH; r++) {
            for (let c = 0; c < data.numCabW; c++) {
                const cabDiv = document.createElement('div');
                cabDiv.innerHTML = `<span class="cab-label">${c + 1}-${r + 1}</span>`;

                const mouseEnterHandler = function (e) {
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `Cabinet: ${c + 1}-${r + 1}<br>Resolution: ${data.cabPixW}x${data.cabPixH}<br>Pixels: ${formatNumber(data.cabPixW * data.cabPixH, 0)}`;
                };
                const mouseMoveHandler = function (e) {
                    tooltip.style.left = `${e.pageX + 10}px`;
                    tooltip.style.top = `${e.pageY - 10}px`;
                };
                const mouseLeaveHandler = function () {
                    tooltip.style.display = 'none';
                };

                cabDiv.addEventListener('mouseenter', mouseEnterHandler);
                cabDiv.addEventListener('mousemove', mouseMoveHandler);
                cabDiv.addEventListener('mouseleave', mouseLeaveHandler);

                cabinetOverlay.appendChild(cabDiv);
            }
        }
        document.getElementById('downloadPdfLink').classList.remove('hidden');
        document.getElementById('visualization').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function hideVisualization() {
        document.getElementById('formContainer').classList.remove('minimized');
        document.getElementById('submitButton').classList.remove('hidden');
        document.querySelector('.back-btn-placeholder').classList.add('hidden');
        document.getElementById('visualization').classList.remove('visible');
        document.getElementById('downloadPdfLink').classList.add('hidden');
        const tooltip = document.getElementById('cabTooltip');
        if (tooltip) tooltip.style.display = 'none';
        document.getElementById('formContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // --- Modal Functions ---
    function populateModalControllers() {
        const select = document.getElementById('modalControllerModel');
        select.innerHTML = '';
        H_SERIES_DEFAULTS.CONTROLLER_OPTIONS.forEach(controller => {
            const opt = document.createElement('option');
            opt.value = controller.model;
            opt.textContent = controller.display;
            select.appendChild(opt);
        });
    }

    function populateModalOutputCards() {
        const select = document.getElementById('modalOutputCardModel');
        select.innerHTML = '';
        const cards = [
            { model: H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL, ports: H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS },
            { model: H_SERIES_DEFAULTS.OUTPUT_CARD_16_MODEL, ports: H_SERIES_DEFAULTS.OUTPUT_CARD_16_PORTS },
            // Include H_4_HDMI_Out as an option (user can opt to include it)
            { model: 'H_4_HDMI_Out', ports: 4 }
        ];
        cards.forEach(card => {
            const opt = document.createElement('option');
            opt.value = `${card.model}|${card.ports}`;
            opt.textContent = `${card.model} (${card.ports} ports)`;
            select.appendChild(opt);
        });
    }

    function populateModalInputCards() {
        const select = document.getElementById('modalInputCardModel');
        select.innerHTML = '';
        H_SERIES_DEFAULTS.INPUT_CARD_OPTIONS.forEach(option => {
            const opt = document.createElement('option');
            opt.value = `${option.model}|${option.qty}`;
            opt.textContent = option.display;
            select.appendChild(opt);
        });
    }

    function updatePortsFromOutputCard() {
        const select = document.getElementById('modalOutputCardModel');
        const [model, ports] = select.value.split('|');
        document.getElementById('modalMaxPortsPerCard').value = ports;
    }

    function openControllerModal() {
        populateModalControllers();
        populateModalOutputCards();
        populateModalInputCards();

        const suggestedControllerName = finalCalculationData.controllerOverrideName ||
            (finalCalculationData.controllerName ? finalCalculationData.controllerName.split('(')[0].trim() : '');
        const controllerSelect = document.getElementById('modalControllerModel');
        if (controllerSelect.querySelector(`option[value="${suggestedControllerName}"]`)) {
            controllerSelect.value = suggestedControllerName;
        }

        document.getElementById('modalSplicerSolution').value = finalCalculationData.splicerSolution || H_SERIES_DEFAULTS.SPLICER_NAME;

        const currentOutputCardValue = `${finalCalculationData.outputCardModel || H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL}|${finalCalculationData.outputCardPorts || H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS}`;
        const outputCardSelect = document.getElementById('modalOutputCardModel');
        if (outputCardSelect.querySelector(`option[value="${currentOutputCardValue}"]`)) {
            outputCardSelect.value = currentOutputCardValue;
        } else {
            outputCardSelect.value = `${H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL}|${H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS}`;
        }
        document.getElementById('modalMaxPortsPerCard').value = finalCalculationData.outputCardPorts || H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS;

        const inputCardModelValue = `${finalCalculationData.inputCardModel}|${finalCalculationData.inputCardQty}`;
        const inputCardSelect = document.getElementById('modalInputCardModel');
        if (inputCardSelect.querySelector(`option[value="${inputCardModelValue}"]`)) {
            inputCardSelect.value = inputCardModelValue;
        } else {
            inputCardSelect.value = `${H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_MODEL}|${H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_QTY}`;
        }

        document.getElementById('modalInputCardQty').value = finalCalculationData.inputCardQty;
        document.getElementById('modalIncludeHdmiOutput').checked = finalCalculationData.includeHdmiOutput || false;

        document.getElementById('controllerModal').style.display = 'block';
    }

    function closeControllerModal() {
        document.getElementById('controllerModal').style.display = 'none';
    }

    function applyModalChanges() {
        const controllerModel = document.getElementById('modalControllerModel').value;
        const splicerSolution = document.getElementById('modalSplicerSolution').value.trim();
        const [outputCardModel, outputCardPorts] = document.getElementById('modalOutputCardModel').value.split('|');
        const [inputCardModel, inputCardQty] = document.getElementById('modalInputCardModel').value.split('|');
        const inputCardQtyManual = parseInt(document.getElementById('modalInputCardQty').value) || H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_QTY;
        const includeHdmiOutput = document.getElementById('modalIncludeHdmiOutput').checked;

        // Find the selected controller's full display name and type
        const selectedController = H_SERIES_DEFAULTS.CONTROLLER_OPTIONS.find(c => c.model === controllerModel);

        finalCalculationData.controllerOverrideName = selectedController.display;
        finalCalculationData.controllerName = selectedController.display;
        finalCalculationData.controllerType = selectedController.type;
        finalCalculationData.splicerSolution = splicerSolution;
        finalCalculationData.outputCardModel = outputCardModel;
        finalCalculationData.outputCardPorts = parseInt(outputCardPorts);
        finalCalculationData.inputCardModel = inputCardModel;
        finalCalculationData.inputCardQty = inputCardQtyManual;
        finalCalculationData.includeHdmiOutput = includeHdmiOutput;

        // Recalculate sending cards based on the new output card ports
        if (finalCalculationData.controllerType === 'Modular') {
            finalCalculationData.requiredSendCards = Math.max(1, Math.ceil(finalCalculationData.requiredPortsBuffered / finalCalculationData.outputCardPorts));
        }

        closeControllerModal();
        showVisualization(); // Re-render the visualization with new controller details
    }

    function openContactModal() {
        document.getElementById('contactModal').style.display = 'block';
        document.getElementById('contactError').classList.add('hidden');
    }

    function closeContactModal() {
        document.getElementById('contactModal').style.display = 'none';
    }

    function handleDownloadRequest() {
        const email = document.getElementById('downloadEmail').value.trim();
        const phone = document.getElementById('downloadPhone').value.trim();
        const contactError = document.getElementById('contactError');
        contactError.classList.add('hidden');

        if (email) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                contactError.textContent = 'Please enter a valid Email ID.';
                contactError.classList.remove('hidden');
                return;
            }
        }
        contactInfo.email = email;
        contactInfo.phone = phone;

        closeContactModal();

        // Fulfill request #8: Download in both PDF and Excel formats
        proceedToDownloadPdf();
        downloadExcelBOQ(finalCalculationData);
    }
    
    // --- NEW FUNCTION: Download BOQ as Excel (CSV) (Request 8) ---
    function downloadExcelBOQ(data) {
        if (!data) return;
        const boqList = generateBOQList(data);
        
        // Define CSV header with pricing columns for Excel
        let csv = "S.No.,Description / Item,Part Code,Quantity,Unit,Unit Price,Total Price\n";
        
        // Add data rows
        boqList.map((item, index) => {
            // Replace commas in description to avoid breaking CSV format
            const description = item.combined.replace(/,/g, ' '); 
            const row = [
                index + 1,
                description,
                item.partcode,
                item.qty,
                item.unit,
                // Add blank placeholders for pricing in Excel formulas
                "", 
                ""
            ];
            csv += row.join(',') + '\n';
        });
        
        // Create and download CSV file
        const link = document.createElement('a');
        link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
        link.download = `PeopleLink_LED_Config_${data.finalResW}x${data.finalResH}_BOQ.csv`; // CSV is easily editable in Excel
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // --- MODIFIED FUNCTION: proceedToDownloadPdf (Requests 1, 2, 3, 4, 5, 6, 7) ---
    function proceedToDownloadPdf() {
        const data = finalCalculationData;
        const { finalW_M, finalH_M, finalW_FT, finalH_FT } = calculateDimensions(data);
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4');
        let y = 8;
        const margin = 10;
        const lineHeight = 5.5;
        const pageW = doc.internal.pageSize.getWidth();
        const primaryColor = [13, 71, 161]; // #0D47A1
        const secondaryColor = [27, 94, 32]; // #1B5E20

        // --- Quotation Format Header --- (Request 1)
        doc.setFontSize(16);
        doc.setTextColor(...primaryColor);
        doc.setFont('inter', 'bold');
        doc.text('PeopleLink LED Video Wall - Quotation & Technical Summary', margin, y);
        y += lineHeight * 2;
        
        doc.setFontSize(10);
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');
        
        // Technical Details Section (updated with Pixel Density)
        const leftColX = margin;
        const rightColX = pageW / 2;
        let curY = y;
        
        // Add Pixel Density (Request 6)
        doc.text('Pixel Density:', leftColX, curY);
        doc.setTextColor(...secondaryColor);
        doc.setFont('inter', 'bold');
        doc.text(`${formatNumber(data.pixelDensity, 0)} Pixels/m²`, leftColX + 45, curY); 
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');
        curY += lineHeight;
        
        doc.text('Final Dimensions:', leftColX, curY);
        doc.setTextColor(...secondaryColor);
        doc.setFont('inter', 'bold');
        doc.text(`${finalW_M.toFixed(2)}m x ${finalH_M.toFixed(2)}m`, leftColX + 45, curY); 
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');
        
        doc.text('Final Resolution:', rightColX, curY);
        doc.setTextColor(...secondaryColor);
        doc.setFont('inter', 'bold');
        doc.text(`${data.finalResW} x ${data.finalResH}`, rightColX + 45, curY);
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');
        curY += lineHeight;
        
        doc.text('Product Model:', leftColX, curY);
        doc.setTextColor(...secondaryColor);
        doc.setFont('inter', 'bold');
        doc.text(data.productName, leftColX + 45, curY);
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');

        doc.text('Total Cabinets:', rightColX, curY);
        doc.setTextColor(...secondaryColor);
        doc.setFont('inter', 'bold');
        doc.text(`${data.totalCabinets} (${data.numCabW} x ${data.numCabH})`, rightColX + 45, curY);
        doc.setTextColor(50, 50, 50);
        doc.setFont('inter', 'normal');
        curY += lineHeight * 2;
        y = curY;

        // --- Visual Box --- (Request 7)
        doc.setFontSize(12);
        doc.setTextColor(...primaryColor);
        doc.setFont('inter', 'bold');
        doc.text('Physical Wall Visualization', margin, y);
        y += lineHeight * 0.5;
        
        const visW_A4_mm = pageW - margin * 2;
        const visH_A4_mm = 40; 
        const aspectRatio = data.finalW_mm / data.finalH_mm;
        let wallW = visW_A4_mm * 0.7; // use 70% of page width for max size
        let wallH = wallW / aspectRatio;

        if (wallH > visH_A4_mm) { // constrain by height
            wallH = visH_A4_mm;
            wallW = wallH * aspectRatio;
        }
        
        // Draw the box
        const centerX = pageW / 2;
        const startX = centerX - wallW / 2;
        doc.setDrawColor(183, 28, 28); // #B71C1C
        doc.setLineWidth(0.5);
        doc.rect(startX, y, wallW, wallH, 'S'); 
        
        // Add dimensions labels
        doc.setFontSize(8);
        doc.setTextColor(183, 28, 28); // #B71C1C
        // Width label
        doc.text(`${finalW_M.toFixed(2)} m W`, centerX, y - 2, { align: 'center' });
        // Height label (rotated)
        doc.saveGraphicsState();
        doc.translate(startX + wallW + 2, y + wallH / 2);
        doc.rotate(90);
        doc.text(`${finalH_M.toFixed(2)} m H`, 0, 0, { align: 'center' });
        doc.restoreGraphicsState();
        
        y += visH_A4_mm + lineHeight * 2;

        // --- Bill of Quantities Table --- (Requests 2, 3, 4, 5)
        doc.setFontSize(12);
        doc.setTextColor(...primaryColor);
        doc.setFont('inter', 'bold');
        doc.text('Bill of Quantities (BOQ) - Pricelist', margin, y); // Request 2
        y += lineHeight * 0.5;

        // Generate BOQ data
        const boqList = generateBOQList(data);
        let tableData = boqList.map((item, index) => {
            // Request 4 (S.No), Request 5 (Unit Price, Total Price placeholders)
            return [
                index + 1, 
                item.combined, 
                item.partcode, 
                item.qty, 
                item.unit, 
                'TBD / Add Formula', 
                'TBD / Add Formula'
            ];
        });

        // Reorder for clarity: put LED Cabinets item first if possible
        const ledWallItemIndex = tableData.findIndex(row => row[1].includes('LED Cabinets'));
        if (ledWallItemIndex > -1) {
            const mainItem = tableData.splice(ledWallItemIndex, 1)[0];
            tableData.unshift(mainItem);
            // Re-index
            tableData.forEach((row, index) => row[0] = index + 1);
        }
        
        doc.autoTable({
            startY: y,
            head: [['S.No.', 'Description / Item', 'Part Code', 'Qty', 'Unit', 'Unit Price', 'Total Price']], // Fixed headers
            body: tableData,
            theme: 'striped',
            styles: { 
                fontSize: 8,
                cellPadding: 1,
                lineColor: 220, 
                lineWidth: 0.1
            },
            headStyles: {
                fillColor: [230, 230, 230],
                textColor: primaryColor,
                fontStyle: 'bold'
            },
            columnStyles: {
                0: { cellWidth: 10, halign: 'center' }, // S.No.
                1: { cellWidth: 70 }, // Description (main width)
                2: { cellWidth: 25, halign: 'center' }, // Part Code
                3: { cellWidth: 15, halign: 'center' }, // Qty
                4: { cellWidth: 15, halign: 'center' }, // Unit
                5: { cellWidth: 25, halign: 'right' }, // Unit Price (pricing column)
                6: { cellWidth: 25, halign: 'right' }  // Total Price (pricing column)
            },
            // Request 3: Fixed width for table (total width 185mm)
            margin: { left: margin, right: margin },
            didDrawPage: (data) => {
                // Footer on every page
                doc.setFontSize(7);
                doc.setTextColor(120, 120, 120);
                doc.text(`Page ${doc.internal.getNumberOfPages()}`, pageW - margin, doc.internal.pageSize.getHeight() - 8, { align: 'right' });
                doc.text('Design figures include a 15% safety margin for power/weight. | PeopleLink Unified Communications Pvt. Ltd.', margin, doc.internal.pageSize.getHeight() - 8);
            }
        });

        // Terms and Conditions
        y = doc.autoTable.previous.finalY + 10;
        if (y > doc.internal.pageSize.getHeight() - 30) {
            doc.addPage(); y = margin;
        }
        
        doc.setFontSize(10);
        doc.setTextColor(...primaryColor);
        doc.setFont('inter', 'bold');
        doc.text('Terms & Conditions', margin, y);
        y += lineHeight;

        const terms = [
          "1) Prices are ex-works/FOB unless otherwise specified.",
          "2) Excludes installation, commissioning, duties, and taxes.",
          "3) Payment terms are TBD and must be agreed upon separately.",
          "4) Lead time is typically 4-6 weeks from confirmation and advance payment.",
          "5) Warranty is 3 years on cabinets/modules and 1 year on control systems. Excludes misuse, surges, unauthorized repairs.",
          "6) Site access and lifting equipment to be provided by client."
        ];
        doc.setFontSize(8);
        let tcy = y;
        terms.forEach(t=>{
          if (tcy > doc.internal.pageSize.getHeight() - 30) {
            doc.addPage(); tcy = margin;
          }
          doc.text(t, margin, tcy);
          tcy += 4.5;
        });

        // Save
        doc.save(`PeopleLink_LED_Config_${data.finalResW}x${data.finalResH}_BOQ.pdf`);
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        toggleMeasurementFields();
        populateModalControllers();
        populateModalOutputCards();
        populateModalInputCards();
        window.onclick = function(event) {
          const controllerModal = document.getElementById('controllerModal');
          const contactModal = document.getElementById('contactModal');
          if (event.target == controllerModal) { controllerModal.style.display = "none"; }
          if (event.target == contactModal) { contactModal.style.display = "none"; }
        }
    });
</script>
