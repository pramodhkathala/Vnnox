<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Active LED Configurator — Single File</title>
  <style>
    :root{--accent:#0b74de;--muted:#666}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f6f8fb;color:#111}
    .wrap{max-width:1200px;margin:28px auto;padding:20px;background:#fff;border-radius:12px;box-shadow:0 6px 22px rgba(13,38,76,0.08)}
    h1{margin:0 0 8px;font-size:20px}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:18px}
    .card{background:#fff;padding:14px;border-radius:10px;border:1px solid #eef2f7}

    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    input[type=number],input[type=text],select{width:100%;padding:8px;border-radius:6px;border:1px solid #d8e1ee;font-size:13px}
    .row{display:flex;gap:10px}
    .small{width:80px}
    .btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .vis-wrap{height:520px;display:flex;flex-direction:column}
    .canvas-wrap{flex:1;border-radius:8px;border:1px dashed #e4ebf5;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#ffffff 0%,#fbfdff 100%);padding:12px}
    #wallCanvas{background:white;border-radius:6px;border:1px solid #e6eef8}
    .stats{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .stat{background:#fbfdff;padding:8px;border-radius:8px;border:1px solid #eef6ff;font-size:13px}
    .hint{font-size:13px;color:#234;opacity:.8}
    .footer{margin-top:12px;color:#556;padding-top:8px;border-top:1px dashed #eef2f7}
    .danger{color:#9b2c2c}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px;border-bottom:1px solid #f1f6fb;font-size:13px;text-align:left}
    .controls{display:grid;gap:8px}
    .inline{display:flex;gap:8px;align-items:center}
    .chip{background:#eef6ff;padding:6px 8px;border-radius:999px;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Active LED Configurator — single-file</h1>
    <p class="hint">Complete interactive configurator: physical wall visualization, cabinet layout, pixel calculations, ports, viewing distance, long-cable & LAN-matrix support. Built with defaults from your earlier inputs.</p>

    <div class="grid">
      <div class="card">
        <h3>Inputs</h3>
        <div class="controls">
          <div>
            <label>Cabinet size (mm)</label>
            <div class="row">
              <input id="cabW" type="number" value="640" title="cabinet width mm" />
              <input id="cabH" type="number" value="480" title="cabinet height mm" />
            </div>
            <small class="hint">Default 640×480 mm (standard). COB example: 600×337.5.</small>
          </div>

          <div>
            <label>Module size (mm)</label>
            <div class="row">
              <input id="modW" type="number" value="320" />
              <input id="modH" type="number" value="160" />
            </div>
          </div>

          <div>
            <label>Pixel pitch (mm)</label>
            <select id="pixelPitch">
              <option value="1.53">1.53 mm</option>
              <option value="1.56" selected>1.56 mm</option>
              <option value="2.07">2.07 mm</option>
              <option value="4">4 mm</option>
            </select>
          </div>

          <div>
            <label>Wall layout — cabinets (W × H)</label>
            <div class="row">
              <input id="cabCols" type="number" value="11" min="1" />
              <input id="cabRows" type="number" value="7" min="1" />
            </div>
            <small class="hint">Your earlier requirement: ~11 cabinets width × 7 height (approx 11ft×7ft physical area). Adjust as needed.</small>
          </div>

          <div>
            <label>Total HDMI Inputs required</label>
            <input id="hdmiInputs" type="number" value="8" />
          </div>

          <div>
            <label>Total HDMI Outputs required</label>
            <input id="hdmiOutputs" type="number" value="8" />
          </div>

          <div>
            <label>Pixels supported per sending-card/port (user-editable)</label>
            <input id="pixelsPerPort" type="number" value="650000" />
            <small class="hint">Default 650,000 pixels (adjust if you know the sending-card spec). VX400 has 4 ports — see Recommendations.</small>
          </div>

          <div>
            <label>Controller / Notes</label>
            <input id="controller" type="text" value="Novastar (recommended)" />
          </div>

          <div>
            <label>Long cable max length (m)</label>
            <input id="maxCable" type="number" value="100" />
            <small class="hint">Set your long-ethernet/active HDMI run capability (typical fiber/active extenders for >100m).</small>
          </div>

          <div>
            <label>LAN cables per cabinet (for matrix / redundancy)</label>
            <input id="lanPerCab" type="number" value="1" min="1" />
            <small class="hint">Example: 5×5 matrix means 5 cables into source matrix. Use redundancy where needed.</small>
          </div>

          <div class="inline">
            <button class="btn" id="renderBtn">Compute & Render</button>
            <div class="chip" id="modelNote">Model note: VX400 has 4 ports — check sending card port capacity</div>
          </div>

        </div>
      </div>

      <div class="card vis-wrap">
        <h3 style="margin-bottom:6px">Physical Wall Visualization</h3>
        <div class="canvas-wrap">
          <canvas id="wallCanvas" width="820" height="420"></canvas>
        </div>

        <div class="stats" id="stats"></div>

        <div class="footer">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <strong>Quick checks:</strong>
              <span class="hint">Viewing distance shown (meters). Ports & sending-card gaps flagged.</span>
            </div>
            <div>
              <span class="hint">Export: save config JSON from the menu (right click the Render button).</span>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div style="margin-top:14px" class="card">
      <h3>Recommendations & Notes</h3>
      <ul>
        <li>Controller: Novastar is recommended for fine pixel control and many sending-card options. Use a sending card that offers sufficient ports for your total pixels.</li>
        <li>If your sending-card (e.g. VX400) only has 4 ports and your wall needs >4 ports, you must use multiple sending cards or a higher-port sending-card or port-splitting.
        </li>
        <li>For long cable runs >100m, prefer fiber or active extenders; for power & redundancy, design 1Gbps+ links per cabinet or an aggregated link per strip.</li>
        <li>Viewing distance guidance: <em>approx</em> = pixel_pitch(mm) × 3 → result in meters (use as a minimum comfortable distance).</li>
      </ul>

      <h4>Example: 5×5 LAN matrix</h4>
      <table>
        <thead><tr><th>Matrix size</th><th>Purpose</th><th>Notes</th></tr></thead>
        <tbody>
          <tr><td>5×5</td><td>Source switching + redundancy</td><td>Each source uses its own lane, plus redundancy. Useful when many HDMI inputs need to be distributed.</td></tr>
        </tbody>
      </table>

    </div>
  </div>

<script>
// Helper & renderer functions — call render() after changing inputs
function elem(id){return document.getElementById(id)}

function calculate() {
  const cabW = Number(elem('cabW').value);
  const cabH = Number(elem('cabH').value);
  const modW = Number(elem('modW').value);
  const modH = Number(elem('modH').value);
  const pixelPitch = Number(elem('pixelPitch').value);
  const cols = Number(elem('cabCols').value);
  const rows = Number(elem('cabRows').value);
  const hdmiIn = Number(elem('hdmiInputs').value);
  const hdmiOut = Number(elem('hdmiOutputs').value);
  const pixelsPerPort = Number(elem('pixelsPerPort').value) || 650000;
  const lanPerCab = Number(elem('lanPerCab').value) || 1;
  const maxCable = Number(elem('maxCable').value) || 100;
  const controller = elem('controller').value || 'Novastar';

  // physical wall mm
  const wallW_mm = cols * cabW;
  const wallH_mm = rows * cabH;
  const wallW_m = +(wallW_mm/1000).toFixed(3);
  const wallH_m = +(wallH_mm/1000).toFixed(3);

  // pixels across and down (rounded to integer)
  const pxAcross = Math.round(wallW_mm / pixelPitch);
  const pxDown = Math.round(wallH_mm / pixelPitch);
  const totalPixels = pxAcross * pxDown;

  // pixels per cabinet (approx)
  const pixelsPerCab = Math.round((cabW / pixelPitch) * (cabH / pixelPitch));

  // ports required
  const portsNeeded = Math.ceil(totalPixels / pixelsPerPort);

  // recommended minimum viewing distance (m) - conservative rule of thumb
  const minViewing_m = +(pixelPitch * 3 / 1000).toFixed(3);
  const comfortableViewing_m = +(pixelPitch * 4 / 1000).toFixed(3);

  // modules and cabinets info
  const modulesPerCabX = Math.round(cabW / modW);
  const modulesPerCabY = Math.round(cabH / modH);
  const modulesPerCab = modulesPerCabX * modulesPerCabY;

  // cable & lan
  const totalCabs = cols * rows;
  const totalLAN = totalCabs * lanPerCab;

  return {
    cabW,cabH,modW,modH,pixelPitch,cols,rows,wallW_m,wallH_m,pxAcross,pxDown,totalPixels,pixelsPerCab,portsNeeded,pixelsPerPort,minViewing_m,comfortableViewing_m,modulesPerCabX,modulesPerCabY,modulesPerCab,totalCabs,totalLAN,hdmiIn,hdmiOut,controller,maxCable
  }
}

function renderWall(calc){
  const canvas = elem('wallCanvas');
  const ctx = canvas.getContext('2d');
  const pad = 18;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map wall mm to canvas
  const mmW = calc.cols * calc.cabW;
  const mmH = calc.rows * calc.cabH;
  const scale = Math.min((canvas.width-2*pad)/mmW, (canvas.height-2*pad)/mmH);
  const drawW = mmW * scale;
  const drawH = mmH * scale;
  const startX = (canvas.width - drawW)/2;
  const startY = (canvas.height - drawH)/2;

  // draw background
  ctx.fillStyle='#f8fbff';
  ctx.fillRect(startX,startY,drawW,drawH);

  // draw cabinets
  for(let r=0;r<calc.rows;r++){
    for(let c=0;c<calc.cols;c++){
      const x = startX + c*calc.cabW*scale;
      const y = startY + r*calc.cabH*scale;
      ctx.fillStyle = ( (r+c)%2===0 )? '#ffffff' : '#fbfeff';
      ctx.fillRect(x,y,calc.cabW*scale,calc.cabH*scale);
      ctx.strokeStyle = '#d8e6f8';
      ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5,y+0.5,calc.cabW*scale-1,calc.cabH*scale-1);

      // small module grid inside cabinet
      const modX = calc.modW*scale;
      const modY = calc.modH*scale;
      ctx.strokeStyle = 'rgba(18,79,146,0.06)';
      ctx.lineWidth = 0.6;
      for(let mx = x; mx < x + calc.cabW*scale - 0.5; mx += modX){
        ctx.beginPath(); ctx.moveTo(mx+0.3,y+0.3); ctx.lineTo(mx+0.3,y+calc.cabH*scale-0.3); ctx.stroke();
      }
      for(let my = y; my < y + calc.cabH*scale - 0.5; my += modY){
        ctx.beginPath(); ctx.moveTo(x+0.3,my+0.3); ctx.lineTo(x+calc.cabW*scale-0.3,my+0.3); ctx.stroke();
      }

      // cabinet label
      ctx.fillStyle='#0b3b72';
      ctx.font='11px Inter, Arial';
      ctx.fillText(`C${r+1}-${c+1}`, x + 6, y + 14);
    }
  }

  // draw border
  ctx.strokeStyle = '#a6c0e8';
  ctx.lineWidth = 1.5;
  ctx.strokeRect(startX,startY,drawW,drawH);

  // draw footprint text
  ctx.fillStyle = '#234';
  ctx.font = '12px Inter, Arial';
  ctx.fillText(`${calc.cols} × ${calc.rows} cabinets — ${calc.wallW_m} m × ${calc.wallH_m} m`, 12, canvas.height - 12);
}

function renderStats(calc){
  const s = elem('stats');
  s.innerHTML = '';

  const make = (title,html) => {
    const d = document.createElement('div'); d.className='stat'; d.innerHTML = `<strong>${title}</strong><div style="margin-top:6px">${html}</div>`; return d;
  }

  s.appendChild(make('Physical size', `${calc.wallW_m} m (W) × ${calc.wallH_m} m (H) — ${calc.totalCabs} cabinets`));
  s.appendChild(make('Resolution (approx)', `${calc.pxAcross} px (W) × ${calc.pxDown} px (H) = <strong>${calc.totalPixels.toLocaleString()}</strong> total pixels`));
  s.appendChild(make('Pixels per cabinet (approx)', `${calc.pixelsPerCab.toLocaleString()} px / cabinet — ${calc.modulesPerCabX}×${calc.modulesPerCabY} modules per cabinet (`+calc.modulesPerCab+')'));
  s.appendChild(make('Porting / Sending-cards', `Pixels per port (used) = <strong>${calc.pixelsPerPort.toLocaleString()}</strong> → Ports needed = <strong>${calc.portsNeeded}</strong> (round-up).`));
  s.appendChild(make('Viewing distance guidance', `Minimum comfortable ≈ <strong>${calc.minViewing_m} m</strong>. Comfortable ≈ <strong>${calc.comfortableViewing_m} m</strong>.`));
  s.appendChild(make('Cabling & LAN', `Total LAN runs (approx) = <strong>${calc.totalLAN}</strong>. Long-cable max run set to ${calc.maxCable} m.`));
  s.appendChild(make('I/O', `HDMI Inputs: ${calc.hdmiIn} — HDMI Outputs: ${calc.hdmiOut} — Controller: ${calc.controller}`));

  // warnings
  if(calc.portsNeeded > 4) {
    const warn = document.createElement('div'); warn.className='stat'; warn.innerHTML = `<strong class="danger">Warning</strong><div style="margin-top:6px">Ports required (${calc.portsNeeded}) &gt; 4. If using a VX400 (4 ports) you must use multiple sending-cards or a different model. Consider Novastar high-port sending-cards or split across multiple cards.</div>`;
    s.appendChild(warn);
  }
}

function exportConfig(calc){
  const data = JSON.stringify(calc, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'led-config.json'; a.click();
  URL.revokeObjectURL(url);
}

function renderAll(){
  const calc = calculate();
  renderWall(calc);
  renderStats(calc);
}

// initial render
renderAll();

// events
elem('renderBtn').addEventListener('click', ()=>{ renderAll(); });

// right-click on button to export
elem('renderBtn').addEventListener('contextmenu', (e)=>{ e.preventDefault(); exportConfig(calculate()); return false; });

</script>
</body>
</html>
