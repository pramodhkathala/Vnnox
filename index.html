function calculateLEDWall(){
  // --- read inputs safely ---
  const productKey = document.getElementById('productModel').value;
  const unit = document.getElementById('unit').value;
  const widthRaw = document.getElementById('width').value;
  const heightRaw = document.getElementById('height').value;
  const diagonalRaw = document.getElementById('diagonal').value;
  const aspectRatioKey = document.getElementById('aspectRatio').value || '';

  const widthInput = widthRaw === '' ? NaN : parseFloat(widthRaw);
  const heightInput = heightRaw === '' ? NaN : parseFloat(heightRaw);
  const diagonalInput = diagonalRaw === '' ? NaN : parseFloat(diagonalRaw);

  const errorDiv = document.getElementById('errorMessage');
  errorDiv.classList.add('hidden');
  errorDiv.textContent = '';

  // --- validation ---
  if (!productKey) {
    errorDiv.textContent = 'ERROR: Please select an LED Model / Pixel Pitch.';
    errorDiv.classList.remove('hidden');
    console.warn('Validation failed: product not selected');
    return null;
  }
  if (!unit) {
    errorDiv.textContent = 'ERROR: Please select Unit of Measurement (meters / feet / inches).';
    errorDiv.classList.remove('hidden');
    console.warn('Validation failed: unit not selected');
    return null;
  }
  if (unit === 'inches') {
    if (isNaN(diagonalInput) || diagonalInput <= 0) {
      errorDiv.textContent = 'ERROR: For Inches unit, please enter a valid diagonal (in inches).';
      errorDiv.classList.remove('hidden');
      console.warn('Validation failed: diagonal missing/invalid');
      return null;
    }
  } else {
    const hasW = !isNaN(widthInput) && widthInput > 0;
    const hasH = !isNaN(heightInput) && heightInput > 0;
    if (!hasW && !hasH) {
      errorDiv.textContent = 'ERROR: Please enter Width or Height (at least one) for meters/feet units.';
      errorDiv.classList.remove('hidden');
      console.warn('Validation failed: width & height missing/invalid');
      return null;
    }
  }

  // --- product details & cabinet dims ---
  const details = LED_PRODUCTS[productKey];
  const cabinetW_mm = details.cabW_mm;
  const cabinetH_mm = details.cabH_mm;

  // --- desired dimensions (mm) ---
  let desiredW_mm = 0;
  let desiredH_mm = 0;

  if (unit === 'inches') {
    // use aspect ratio if provided, otherwise default to 16:9
    const ratioToUse = aspectRatioKey || '16:9';
    const [rW, rH] = ratioToUse.split(':').map(Number);
    const rDiag = Math.sqrt((rW * rW) + (rH * rH));
    const factor = diagonalInput / rDiag; // diagonalInput is in inches
    desiredW_mm = rW * factor * MM_PER_INCH;
    desiredH_mm = rH * factor * MM_PER_INCH;
  } else {
    const unitFactor = (unit === 'meters') ? MM_PER_METER : MM_PER_FOOT;
    const hasW = !isNaN(widthInput) && widthInput > 0;
    const hasH = !isNaN(heightInput) && heightInput > 0;

    if (aspectRatioKey) {
      const [rW, rH] = aspectRatioKey.split(':').map(Number);
      if (hasW) {
        desiredW_mm = widthInput * unitFactor;
        desiredH_mm = (widthInput / rW) * rH * unitFactor;
      } else if (hasH) {
        desiredH_mm = heightInput * unitFactor;
        desiredW_mm = (heightInput / rH) * rW * unitFactor;
      } else {
        desiredW_mm = (isNaN(widthInput) ? 0 : widthInput) * unitFactor;
        desiredH_mm = (isNaN(heightInput) ? 0 : heightInput) * unitFactor;
      }
    } else {
      // infer missing dimension from cabinet AR if only one provided
      const cabAR = cabinetW_mm / cabinetH_mm;
      if (hasW && !hasH) {
        desiredW_mm = widthInput * unitFactor;
        desiredH_mm = desiredW_mm / cabAR;
      } else if (hasH && !hasW) {
        desiredH_mm = heightInput * unitFactor;
        desiredW_mm = desiredH_mm * cabAR;
      } else { // both given or both zero (but validation prevented both zero)
        desiredW_mm = (isNaN(widthInput) ? 0 : widthInput) * unitFactor;
        desiredH_mm = (isNaN(heightInput) ? 0 : heightInput) * unitFactor;
      }
    }
  }

  // --- snap to nearest whole cabinets ---
  const numCabW = Math.max(1, Math.round(desiredW_mm / cabinetW_mm));
  const numCabH = Math.max(1, Math.round(desiredH_mm / cabinetH_mm));
  const totalCabinets = numCabW * numCabH;
  const totalModules = totalCabinets * details.modulesPerCab;
  const finalW_mm = numCabW * cabinetW_mm;
  const finalH_mm = numCabH * cabinetH_mm;
  const finalArea_m2 = (finalW_mm / MM_PER_METER) * (finalH_mm / MM_PER_METER);

  // --- resolution & pixels ---
  const finalResW = numCabW * details.cabPixW;
  const finalResH = numCabH * details.cabPixH;
  const totalPixels = finalResW * finalResH;

  const ratioGCD = gcd(finalResW, finalResH);
  const aspectRatioText = `${finalResW / ratioGCD}:${finalResH / ratioGCD}`;
  const finalDiagonal_mm = Math.sqrt((finalW_mm * finalW_mm) + (finalH_mm * finalH_mm));
  const finalDiagonal_in = finalDiagonal_mm / MM_PER_INCH;

  // --- viewing distance (1x / 2x / 3x pitch in meters -> feet) ---
  const minView_m = details.pitch_mm / 1000; // 1x pitch in meters
  const comfortView_m = (details.pitch_mm * 2) / 1000; // 2x
  const idealView_m = (details.pitch_mm * 3) / 1000; // 3x
  const minView_ft = minView_m * METER_TO_FEET;
  const comfortView_ft = comfortView_m * METER_TO_FEET;
  const idealView_ft = idealView_m * METER_TO_FEET;

  // --- power & weight calculations ---
  const actualPower_W_unbuffered = finalArea_m2 * details.maxPower_W_m2;
  const maxPower_W_buffered = actualPower_W_unbuffered * POWER_BUFFER;
  const actualCurrent_A = actualPower_W_unbuffered / 220;
  const maxCurrent_A_buffered = maxPower_W_buffered / 220;
  const actualCabinetWeight_unbuffered = details.weight_kg * totalCabinets;
  const totalWallWeight_buffered = actualCabinetWeight_unbuffered * WEIGHT_BUFFER;

  // ------------------------------
  // Long-cable & ports / sending card logic (updated)
  // - bandwidth_ports_needed = ceil(totalPixels / PIXELS_PER_PORT_DEFAULT)
  // - cabPixels = cabPixW * cabPixH
  // - cabinets_per_long_cable = floor(PIXELS_PER_PORT_DEFAULT / cabPixels) [minimum 1]
  // - cables_needed_by_cabinets = ceil(totalCabinets / cabinets_per_long_cable)
  // - requiredPorts = max(bandwidth_ports_needed, cables_needed_by_cabinets)
  // ------------------------------
  const bandwidth_ports_needed = Math.max(1, Math.ceil(totalPixels / PIXELS_PER_PORT_DEFAULT));
  const cabPixels = details.cabPixW * details.cabPixH;
  let cabinets_per_long_cable = Math.floor(PIXELS_PER_PORT_DEFAULT / cabPixels);
  if (cabinets_per_long_cable < 1) cabinets_per_long_cable = 1; // at least 1 cabinet per cable
  const cables_needed_by_cabinets = Math.max(1, Math.ceil(totalCabinets / cabinets_per_long_cable));
  const requiredPorts = Math.max(bandwidth_ports_needed, cables_needed_by_cabinets);

  const outputCardPorts = finalCalculationData.outputCardPorts || H_SERIES_DEFAULTS.OUTPUT_CARD_20_PORTS;
  const outputCardModel = finalCalculationData.outputCardModel || H_SERIES_DEFAULTS.OUTPUT_CARD_20_MODEL;
  const requiredSendCards = Math.max(1, Math.ceil(requiredPorts / outputCardPorts));
  const requiredShortEthernet = Math.max(0, totalCabinets - requiredPorts);

  // --- controller suggestion + escalation if ports insufficient ---
  let suggestedController = getSuggestedControllerModel(totalPixels, finalResW, finalResH, productKey, requiredPorts);
  if (suggestedController.ports < requiredPorts) {
    // try to find controller with enough ports and sufficient pixel capacity
    let escalated = CONTROLLER_MODELS.find(c => c.ports >= requiredPorts && c.maxPixels >= totalPixels);
    if (!escalated) {
      // find any controller with enough ports (even if pixel cap smaller)
      escalated = CONTROLLER_MODELS.find(c => c.ports >= requiredPorts);
    }
    if (escalated) suggestedController = escalated;
    else suggestedController = CONTROLLER_MODELS[CONTROLLER_MODELS.length - 1];
  }

  const controllerName = finalCalculationData.controllerOverrideName || suggestedController.name;

  // --- write finalCalculationData object used across the UI ---
  finalCalculationData = {
    productName: details.name,
    pixelPitch_mm: details.pitch_mm,
    cabinetW_mm: cabinetW_mm,
    cabinetH_mm: cabinetH_mm,
    cabPixW: details.cabPixW,
    cabPixH: details.cabPixH,
    finalW_mm: finalW_mm,
    finalH_mm: finalH_mm,
    finalArea_m2: finalArea_m2,
    finalResW: finalResW,
    finalResH: finalResH,
    totalPixels: totalPixels,
    aspectRatioText: aspectRatioText,
    finalDiagonal_in: finalDiagonal_in,
    totalCabinets: totalCabinets,
    totalModules: totalModules,
    totalRecCards: totalCabinets,
    numCabW: numCabW,
    numCabH: numCabH,
    modulesPerCab: details.modulesPerCab,
    nits_range: details.nits_range,
    minView_m: minView_m,
    comfortView_m: comfortView_m,
    idealView_m: idealView_m,
    minView_ft: minView_ft,
    comfortView_ft: comfortView_ft,
    idealView_ft: idealView_ft,
    actualPower_W_unbuffered: actualPower_W_unbuffered,
    maxPower_W: maxPower_W_buffered,
    actualCurrent_A: actualCurrent_A,
    maxCurrent_A_buffered: maxCurrent_A_buffered,
    actualWallWeight_unbuffered: actualCabinetWeight_unbuffered,
    totalWallWeight_buffered: totalWallWeight_buffered,
    controllerName: controllerName,
    controllerType: suggestedController.type,
    bandwidth_ports_needed: bandwidth_ports_needed,
    cabPixels: cabPixels,
    cabinets_per_long_cable: cabinets_per_long_cable,
    cables_needed_by_cabinets: cables_needed_by_cabinets,
    requiredPorts: requiredPorts,
    requiredShortEthernet: requiredShortEthernet,
    outputCardPorts: outputCardPorts,
    outputCardModel: outputCardModel,
    requiredSendCards: requiredSendCards,
    inputCardModel: finalCalculationData.inputCardModel || H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_MODEL,
    inputCardQty: finalCalculationData.inputCardQty || H_SERIES_DEFAULTS.DEFAULT_INPUT_CARD_QTY,
    splicerSolution: finalCalculationData.splicerSolution || (suggestedController.type.includes('Modular') ? H_SERIES_DEFAULTS.SPLICER_NAME : 'N/A'),
    controllerOverrideName: finalCalculationData.controllerOverrideName || null
  };

  return finalCalculationData;
}
